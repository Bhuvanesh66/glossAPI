Στο πλαίσιο αυτής της εργασίας θα μελετήσουμε το NPcomplete Bin Packing Problem. 
Δεδομένου ενός συνόλου αριθμών/βαρών και ενός συνόλου από κάδους (bins) 
δεδομένης χωρητικότητας, να βρεθεί ο ελάχιστος αριθμός bins που απαιτούνται, ώστε 
να περιέχονται όλα τα βάρη/αριθμοί σε bins και κανένα bin να μην ξεπερνά την 
χωρητικότητά του. Θα δούμε τις κυριότερες πρακτικές εφαρμογές του Bin Packing 
Problem. Θα αναφέρουμε και θα μελετήσουμε τους σημαντικότερους αλγόριθμους που 
χρησιμοποιούνται για την λύση του προβλήματος και τις σημαντικότερες εφαρμογές 
του. Επιπλέον θα μελετήσουμε το πρόβλημα του Bin Packing Problem σε αντιστοιχία με 
το MapReduce καθώς μπορεί να μας δώσει λύσεις στην μελέτη του προβλήματος σε 
κλίκες και θα δούμε ακόμα το πρόβλημα σε μονοπάτι όπου κάθε στοιχείο Χι οφείλει να 
βρίσκεται στον ίδιο κάδο με το Χι+1 προτείνοντας κάποιους αλγόριθμους που λύνουν το 
πρόβλημα μελετώντας τα θετικά και τα αρνητικά τους. 

Με την ολοκλήρωση της πτυχιακής, ουσιαστικά έρχεται και η ολοκλήρωση του κύκλου 
σπουδών μου στο τμήμα της Πληροφορικής και Τηλεπικοινωνιών. Ως εκ τούτου θα 
ήθελα να εκφράσω την ευγνωμοσύνη μου σε όλους αυτούς που με βοήθησαν στην 
πορεία αυτή. Ξεκινώντας από τους καθηγητές και του συμφοιτητές που ήταν ανά πάσα 
στιγμή διαθεσίμου για να λύσουν τους προβληματισμούς που προέκυπταν μέσα από 
τον κύκλο σπουδών. Δεν θα μπορούσα πότε να παραλείψω την οικογένεια μου που με 
στήριξε απεριόριστα στο διάστημα αυτό. 
Ιδιαίτερα θα ήθελα να ευχαριστήσω από του καθηγητές τον επιβλέποντα καθηγητή της 
παρούσας πτυχιακής τον κ. Ζησιμόπουλο, για την αμέριστη βοήθεια του στα πλαίσια 
της πτυχιακής και την άμεση ανταπόκριση του στους διάφορους προβληματισμούς που 
είχα κατά την διάρκεια της εκπόνησης της εργασίας 

Το πρόβλημα του bin packing αποτελεί ένα ενδιαφέρων ιστορικά πρόβλημα. 
Πρόβλημα στο οποίο αντικείμενα με διαφορετικές ποσότητες πρέπει να πακεταριστούν 
σε ένα πεπερασμένο αριθμό από bins (κάδους) σταθερής χωρητικότητας, έτσι ώστε 
κανένα bin να μην ξεπερνά την χωρητικότητα του και παράλληλα να χρησιμοποιηθούν 
τα ελάχιστα bins. 
Tο Βin Ρacking Ρroblem μπορεί να συνδεθεί με μια άλλη πολύ σημαντική κατηγορία 
προβλημάτων επιχειρησιακής έρευνας. Το Βin Ρacking Ρroblem μπορούμε να το δούμε 
σαν μια ιδιαίτερη περίπτωση του cutting stock problem. Όταν ο αριθμός των bins 
περιοριστεί στο 1 και κάθε αντικείμενο χαρακτηρίζεται από ποσότητα και αξία, το 
πρόβλημα της συμπλήρωσης ενός bin έτσι ώστε να περιέχει τα μεγαλύτερο δυνατό 
μέρισμα αξιών είναι γνωστό ως knapsack problem. 
Από άποψη υπολογιστικής πολυπλοκότητας το πρόβλημα του Bin Packing είναι ΝΡ-hard. 
Παρά το γεγονός ότι είναι ΝΡhard μπορούμε να βρούμε λύσεις χρησιμοποιώντας 
διάφορους αλγόριθμους. Σε πολλές περιπτώσεις βέλτιστες λύσεις μπορούν να βρεθούν 
χρησιμοποιώντας αποτελεσματικούς ευρετικούς αλγορίθμους. Για 
παράδειγμα ο αλγόριθμος First Fit, στον οποίο θα αναφερόμαστε ως FF, μας δίνει μια 
γρήγορη λύση αλλά συχνά δεν είναι η βέλτιστη, βάζοντας τα αντικείμενα στο πρώτο bin 
στο οποίο χωράνε. Ο αλγόριθμος μπορεί να γίνει ποιο αποτελεσματικός ταξινομώντας 
εκ τον προτέρων τα αντικείμενα με φθίνουσα σειρά, γνωστό ως First Fit decreasingly, 
παρόλο που ούτε αυτό μας εγγυάται την βέλτιστη λύση και για μεγάλες λίστες κάνει τον 
αλγόριθμο πιο αργό, προστίθεται ουσιαστικά χρόνος για την ταξινόμηση. Είναι γνωστό 
παρόλα αυτά ότι υπάρχει σειρά αντικειμένων τέτοια ώστε ο FF να μας δώσει την 
βέλτιστη λύση. 
Πολλοί εξελικτικοί εφευρετικοί αλγόριθμοι, περιλαμβάνοντας τους 
γενετικούς αλγόριθμους και τους πρακτικούς αλγόριθμους σμήνους 
(swarm algorithms) επινοήθηκαν για να βρουν λύση στο Bin Packing Problem. Παρά το 
γεγονός ότι μερικά προβλήματα Βin Packing είναι ΝΡcomplete επιδέχονται 
προγραμματιστικής λύσης, ή προσεγγιστικής ευρετικής λύσης. 
Εδώ γεννιέται το ερώτημα για να βρεθεί βέλτιστη λύση, όταν υπάρχουν 
προσεγγιστικές λύσεις υψηλής ποιότητας. Σε πολλές εφαρμογές είναι σημαντικό να 
βρεθεί η βέλτιστη λύση, συγκεκριμένα όταν ο αριθμός των bins πρέπει να είναι μικρός 
και κάθε επιπλέον bin να είναι ιδιαίτερα ακριβό (πχ μεταφορές, job scheduling CPU), η 
βέλτιστη λύση μειώνει δραστικά το κόστος. Επιπλέον όταν μπορούμε να διακρίνουμε 
ποια είναι η βέλτιστη λύση για ένα πρόβλημα, μπορούμε να υπολογίσουμε με 
μεγαλύτερη ακρίβεια την ποιότητα τον υπόλοιπων λύσεων. Ενώ δεν πρέπει να 
παραβλέπουμε ότι το βέλτιστο Bin Packing παραμένει μια ενδιαφέρουσα υπολογιστική 
πρόκληση που μπορεί να οδηγήσει σε γνώση χρήσιμη σε άλλα προβλήματα. 

Σε αυτή την ενότητα θα ασχοληθούμε με τις πρακτικές εφαρμογές του Βin Ρacking 
Ρroblem στις διαφορετικές εκδοχές του, που το καθιστούν επίκαιρο και διαρκώς 
ενδιαφέρον πρόβλημα. Οι πλέον εμφανείς εφαρμογές του Bin Packing έρχονται από τον 
χώρο της βιομηχανίας, όπου βρίσκει εφαρμογές στα διάφορα στάδια από την 
παραγωγή έως την διανομή. 
Από την πρώτη κιόλας γραμμή συναρμολόγησης το ζητούμενο ήταν να βελτιώσουν 
την γραμμή καλύπτοντας διάφορους περιορισμούς. Ο επιθυμητός στόχος ήταν οι 
διεργασίες να συμβαίνουν σε διάφορους σταθμούς εργασίας με τέτοιο τρόπο ώστε τα 
παράγωγα του ενός, τα οποία ταυτόχρονα αποτελούσαν προϊόντα του άλλου, να μην 
ξεπερνά τον ρυθμό παράγωγης τους το ρυθμό κατανάλωσης τους (γνωστό ως 
Assembly Line Balancing Problem). Μας δίνονται διεργασίες διαφορετικών μεγεθών, 
που υπόκεινται σε δεσμεύσεις προτεραιότητας και χρονικών δεσμεύσεων και μπορεί να 
εκφραστεί ως BPP με περιορισμούς. 
Ένα ακόμα χαρακτηριστικό παράδειγμα είναι αυτό της κοπής αποθεμάτων από 
διάφορα υλικά όπως τα μέταλλα, που παρασκευάζονται σε σταθερά μεγέθη και 
διαμορφώνονται ανάλογα με την παραγγελία. Οι παραγγελίες έρχονται σε τυχαία 
μεγέθη, οπότε το πρόβλημα που δημιουργείται είναι πώς θα χρησιμοποιήσουμε τον 
ελάχιστο αριθμό από τα προκαθορισμένα τμήματα για να καλύψουμε την παραγγελία. 
Ιδιαίτερο ενδιαφέρον παρουσιάζει η εφαρμογή του Bin Packing Problem στον τομέα 
της αποθήκευσης και της διανομής, όπως στη φόρτωση των φορτηγών και των 
κοντέινερ. Τα αντικείμενα συχνά ποικίλλουν σε μεγέθη και σε σχήματα ενώ πολλά 
πιθανών να απαιτούν συγκεκριμένο τρόπο τοποθέτησης (οριζόντια/κάθετα) ή ακόμα και 
συγκεκριμένες συνθήκες όπως η θερμοκρασία και η υγρασία, που καθιστούν την 
αποθήκευση και την μεταφορά τους ιδιαιτέρως κοστοβόρα, οδηγώντας σε επιθυμία για 
όσο το δυνατόν μεγαλύτερη πληρότητα του χώρου. 
Ο προγραμματισμός των project μιας εταιρίας θυμίζει το Bin Packing Problem σε 
πολλά σημεία. Το πρόβλημα της κατανομής τον εργασιών σε χρονοδιάγραμμα μπορεί 
να εκφραστεί σαν Bin Packing Problem, οι διάφοροι αλγόριθμοι μπορούν να 
χρησιμοποιηθούν άκοπα σε αυτή την περίπτωση. 
Η κατανομή του προϋπολογισμού έχει κοινά χαρακτηριστικά από το knapsack 
problem, όπου ένα συγκεκριμένο ποσό πρέπει να μοιραστεί σε διαφορετικές διεργασίες 
με διαφορετικό κόστος. Έχοντας κατά νου την ομοιότητα, μπορούμε να ωφεληθούμε 
από τις διαδικασίες του knapsack problem στη μακροπρόθεσμη και βραχυπρόθεσμη 
κατανομή του budget. 
Αξιομνημόνευτες και ιδιαίτερου ενδιαφέροντος είναι οι εφαρμογές του Bin Packing 
Problem στο χώρο της πληροφορικής. Με τον όγκο τον δεδομένων που 
χρησιμοποιούμε τόσο στα δικά μας μέσα όσο και σε εφαρμογές cloud η όσο το δυνατόν 
καλύτερη κατανομή εγκυρότατα στο Bin Packing Problem. Ιδιαίτερα στο cloud storage η 
υπηρεσία παρέχεται από πληθώρα αποθηκευτικών οντοτήτων, υπευθύνων για την 
αποθήκευση και τη φύλαξη τον πληροφοριών. Οι πληροφορίες αποθηκεύονται σε 
σκληρούς δίσκους (συνήθως ίδιου μεγέθους, διότι συμφέρει στο κόστος και στην 
συντήρηση), αν δούμε τον δίσκο ως bin και τον όγκο των δεδομένων που πρέπει να 
αποθηκεύσουμε ως αντικείμενο το οποίο πρέπει να αποθηκευτεί εξ ολοκλήρου σε ένα 
δίσκο βρισκόμαστε ακριβός πάνω στις βασικές αρχές του Bin Packing με το κέρδος σε 
κόστος από την όσο το δυνατόν καλύτερη κατανομή να είναι κάτι παραπάνω από 
εμφανές. 

Σε αυτή την ενότητα θα δώσουμε την μαθηματική έκφραση του βασικού Βin Ρacking 
Ρroblem. Το Βin Ρacking Ρroblem μπορεί να οριστεί ως εξής. Έχουμε αρκετούς κάδους 
ή bins (του ίδιου μεγέθους), καi επιθυμούμε να πακετάρουμε n αντικείμενα σε όσο το 
δυνατών λιγότερους κάδους. Tο Βin Ρacking Ρroblem είναι ένα NP-hard problem. 
Από τη στιγμή που το πρόβλημα είναι ΝΡ-hard, να βρούμε τη βέλτιστη λύση είναι 
μια πολύ χρονοβόρα διαδικασία και στις περισσότερες περιπτώσεις δεν είναι το 
προτιμητέο, ειδικά για μεγάλου μεγέθους περιπτώσεις. Γι'αυτό πολλές περιπτώσεις 
προτιμήσαμε λύσεις που μπορούν να βρεθούν χρησιμοποιώντας αποτελεσματικούς 
προσεγγιστικούς αλγορίθμους. Πριν δούμε αυτούς του αλγόριθμους καλό είναι να δούμε 
εν συντομία τι σημαίνει ΝΡ-hard και γιατί το Βin Ρacking Ρroblem είναι ΝΡhard 
2.2 N P -hardness 
Στην υπολογιστική θεωρία πολυπλοκότητας, η ΝΡ είναι μια από τις πιο θεμελιώδεις 
κλάσεις πολυπλοκότητας. Η συντομογραφία NP αναφέρεται σε "μη-ντετερμινιστικό 
πολυωνυμικό χρόνο".Διαισθητικά, το NP είναι το σύνολο όλων των προβλημάτων 
απόφασης, για τα οποία οι περιπτώσεις όπου η απάντηση είναι "ναι" υπάρχει 
επιβεβαιωμένη αποδείξει για το γεγονός ότι η απάντηση είναι όντως «ναι». Πιο 
συγκεκριμένα, οι αποδείξεις αυτές πρέπει να είναι επαληθεύσιμες σε πολυωνυμικό 
χρόνο από μια ντετερμινιστική μηχανή Turing. Σε ένα ισοδύναμο επίσημο ορισμό, NP 
είναι το σύνολο προβλημάτων απόφασης, όπου οι "ναι" -περιπτώσεις μπορούν να 
γίνουν αποδεκτές σε πολυωνυμικό χρόνο από μια μη-ντετερμινιστική μηχανή Turing. Η 
ισοδυναμία των δύο ορισμών προκύπτει από το γεγονός ότι ένας αλγόριθμος σε μια 
τέτοια μη-ντετερμινιστική μηχανή αποτελείται από δύο φάσεις, η πρώτη η οποία 
αποτελείται από μια εικασία για τη λύση, η οποία δημιουργείται με ένα μη-
ντετερμινιστικό τρόπο, ενώ η δεύτερη αποτελείται από έναν ντετερμινιστικό αλγόριθμο 
που επαληθεύει ή απορρίπτει την εικασία ως έγκυρη λύση στο πρόβλημα. 
ΝΡ-hard προβλήματα είναι εκείνα τα προβλήματα τα οποία είναι τουλάχιστον τόσο 
δύσκολα όσο τα NP προβλήματα, δηλαδή, όλα τα προβλήματα NP μπορούν να 
αναχθούν (σε πολυωνυμικό χρόνο) σε αυτά. Τα ΝΡ-hard προβλήματα δεν χρειάζεται να 
είναι στο NP, δηλαδή, ότι δεν χρειάζεται να έχουν λύσεις ελεγμένες σε πολυωνυμικό 
χρόνο. 
Για να δείξουμε ότι το Bin Packing Problem είναι ΝΡ-hard το ανάγουμε στο ΝΡ 
πρόβλημα του 2Partition. 
Το Bin Packing είναι NP-hard. Δεν υπάρχει κανένας αλγόριθμος k-προσέγγιστικός με k 
< 3/2 (εκτός αν P = NP). 
Είναι εύκολο να δούμε ότι η απάντηση στο παράδειγμα κατανομής/Partition είναι ΝΑΙ, 
αν και μόνο αν ο ελάχιστος αριθμός των κάδων για το Bin Packing είναι 2. 
Αν υπήρχε ένας αλγόριθμος k-προσέγγιστικός για το 
Bin Packing με k < 3/2 , στη συνέχεια, όταν το ακριβές ελάχιστο είναι 2 κάδοι, ο 
αλγόριθμος αυτός θα το βρείσκει πάντα, από τους 3 κάδους και μετά θα ήταν μια 
προσέγγιση με συντελεστή ≥ 3/2 . Έτσι, από την ως άνω μείωση, ο αλγόριθμος αυτός 
θα έλυνε ακριβώς το πρόβλημα του Partition σε πολυωνυμικό χρόνο, πράγμα που θα 
σήμαινε P = NP. 

Σε αυτό το σημείο θα μελετήσουμε τους κυριότερους απλούς αλγόριθμους που 
χρησιμοποιούνται για την λύση του Βin Packing Problem. Χωρίζουμε τους αλγόριθμους 
σε τρεις κατηγορίες, τους online αλγόριθμους, semi-online αλγόριθμους και τους offline 
αλγόριθμους. Οι online αλογοριθμοι εφαρμοζονται με οταν έρθει το πρώτο αντικείμενο 
και κάθε αντικείμενο που τοποθετείται δεν μπορεί να επανατοποθετηθεί. Οι semi-online 
αλγόριθμοι αφαιρούν τον περιορισμό όπου τα αντικείμενα δεν μπορούν να 
επανατοποθετηθούν. Επιτρέπουν τα συσκευασμένα αντικείμενα να κινηθούν μετά τη 
συσκευασία. Ο αριθμός τον μετακινήσεων εξαρτάται από τον σχεδιασμό του 
αλγορίθμου. Οι offline αλγόριθμοι περιλαμβάνουν την υπόθεση ότι όλα τα αντικείμενα 
έχουν φτάσει πριν ξεκινήσει ο αλγόριθμος και έτσι μπορούν να διαταχτούν πριν 
ξεκινήσει ο κάθε αλγόριθμος. Το αποτέλεσμα είναι να πάρουμε αλγόριθμους με 
καλύτερη worstcase performance σε σχέση με τους online και τους semi-online. 

O απλούστερος αλγόριθμος για μια προσεγγιστική λύση στο ΒΡΡ είναι ο ΝextFit 
αλγόριθμος ,το οποίο θα συμβολίζουμε ως ΝF. Στον ΝF ακολουθείται η εξής διαδικασία. 
Το πρώτο αντικείμενο προς τοποθέτηση ανατίθεται στον κάδο 1. Έχοντας τα 
αντικείμενα 2,...,n κάθε ένα από αυτά ανατίθεται στον τρέχοντα κάδο, αν χωράει 
τοποθετείται, αλλιώς ανατίθεται στον επόμενο ο οποίος γίνεται με την σειρά του ο 
τρέχον. Η πολυπλοκότητα του αλγόριθμου είναι προφανώς Ο(n). Είναι εύκολο να 
αποδειχθεί ότι για κάθε στιγμιότυπο του ΒΡΡ η υπολογιστική αξία NF(I) ικανοποιεί το 
όριο NF(I) ≤2 z(I). 
Η βέλτιστη λύση για κάθε στιγμιότυπο Ι συμβολίζεται ως z(I).Συχνά συμβολίζεται και ως 
OPT από τα αρχικά του optimal solution. Έστω ότι έχουμε την κακή περίπτωση όπου 
κάθε αντικείμενο που ελέγχουμε δεν χωράει στον ίδιο κάδο με το προηγούμενο. 
Έχουμε ως Β1 τον πρώτο κάδο που θα χρησιμοποιήσουμε Β2 τον δεύτερο και πάει 
λέγοντας, έχουμε να κατανείμουμε n αντικείμενα που θα κατανεμηθούν το καθένα σε 
διαφορετικό κάδο. 

Harmonic Fit (HF): O HF χωρίζει τα αντικείμενα σε σετ ανάλογα με το μέγεθος τους. Ο 
αριθμός των σετ μπορεί να είναι οποιοσδήποτε θετικός ακέραιος μεγαλύτερος από ένα. 
Στη συνέχεια, ο ΝF εφαρμόζεται σε κάθε σετ χωριστά όπως στο παράδειγμα. 
 
Ένας άλλος αλγόριθμος είναι ο FirstFit (FF), έστω ότι έχουμε τα αντικείμενα με 
αύξουσα σειρά δεικτών,αναθέτουμε το κάθε αντικείμενο στον πρώτο κάδο στον οποίο 
χωράει (σύμφωνα με τη σειρά που τους χρησιμοποιήσαμε). Αν το αντικείμενο δεν 
χωράει σε κανένα από τους ήδη υπάρχοντες κάδους (bins), τότε πάμε σε νέο κάδο 
όπως στο παράδειγμα. 
Εάν υποθέτουμε ότι υπάρχουν n αντικείμενα, όπου το μέγεθος κάθε αντικειμένου, 
si, είναι αυστηρά μεταξύ 0 και 1. Θέλουμε να τοποθετήσουμε τα αντικείμενα στον 
ελάχιστο αριθμό κάδων μεγέθους 1. Κάθε κάθος μπορεί να διατηρεί οσαδήποτε 
αντικείμενα, αρκεί το άθροισμα των μεγεθών τους να μην ξεπερνά τη χωρητικότητα του 
κάδου. O First Fit Heuristic μεταχειρίζεται τα αντικείμενα στη σειρά και τοποθετεί κάθε 
αντικείμενο στον πρώτο κάδο που αυτό χωράει. 

O επόμενος αλγόριθμος είναι ο ΒestFit συμβολιζόμενος ως ΒF, o αλγόριθμος BF προέρχεται 
από τον αλγόριθμο FF, τοποθετώντας όμως το αντικείμενο προς τοποθέτηση στον διαθέσιμο κάδο 
(αν αυτός υπάρχει) με τον μικρότερο διαθέσιμο υπολειπόμενο χώρο. Οι Johnson, Demers, Ullman, Garey και 
Graham (1974 ) απέδειξαν οτι ισχύει το ίδιο worstcase όριο με τον FF δηλαδή 
r∞(ΒF) = 17/10. 
Η χρονική πολυπλοκότητα των NF και BF είναι Ο (n logn). Αυτό επιτυνχάνεται 
χρησιμοποιώντας ένα 23 δέντρο όπου τα φύλλα του αποθηκεύουν την υπολειπόμενη 
χωρητικοτητα τον χρησιμοποιημένων κάδων. (Το δέντρο 23 είναι ένα δέντρο του 
οποίου: (a) κάθε κόμβος που δεν είναι φύλλο έχει 2 έως 3 παιδιά,(b) κάθε μονοπάτι 
από την ρίζα στον φύλλο έχει το ίδιο μήκος, (c) ταμπέλες στους κόμβους επιτρέπουν 
την αναζήτηση συγκεκριμένης αξίας φύλλου, αναβαθμίζοντάς το ή εισάγοντας νέο 
φύλλο σε Ο(n) χρόνο. Με αυτόν τον τρόπο κάθε προσέγγιση του FF ή του BF απαιτεί Ο(logn) χρόνο, 
μιας και ο αριθμός των φύλλων περιορίζεται από το n. 

Μια συνάρτηση υπολογισμού του κάτω ορίου του bin packing, που υπολογίζει 
αποτελεσματικά το κάτω όριο είναι απαραίτητη. Δοθείσης ενός κάτω ορίου για το bin 
packing problem, αν βρούμε μια λύση που χρησιμοποιεί τον ίδιο αριθμό από bins όπως 
το κάτω όριο γνωρίζουμε ότι έχουμε την βέλτιστη λύση και μπορούμε να σταματήσουμε 
τον έλενχο. Ένα προφανές κάτω όριο είναι το άθροισμα τον αντικειμένων διαιρούμενο με 
την χωρητικότητα των bins στρογγυλοποιημένα στον πάνω ακέραιο. Ένα καλύτερο όριο 
ξεκινά με το άθροισμα τον αντικειμένων και προσθέτει ένα εκτιμώμενο ποσό για την 
συνολική σπατάλη περιεκτικότητας στην κάθε λύση, πριν το διαιρέσει με την 
περιεκτικότητα. Αυτό είναι το L2 όριο των Martello and Toth. 
Έστω ότι w είναι ο αχρησιμοποίητος χώρος αρχικοποιημένος σε 0, έχοντας 
περιεκτικότητα bins C και ένα σετ αντικειμένων S (s1,s2,..,sn). Όσο υπάρχουν 
αντικείμενα στο S, αφαιρέσουμε το μεγαλύτερο αντικείμενο s1 και υπολογίζουμε την 
υπολειπόμενη περιεκτικότητα r = C − s1 που απομένει αφού το s1 τοποθετηθεί στο bin. Τότε 
αφαιρούμε από το S όλα τα αντικείμενα με αξία ίση η μικρότερη από το r και 
αποθηκεύουμε το άθροισμα τους στην μεταβλητή sum. Αν το sum ≤ r , προσθέτουμε 
το r − sum στο W. Αν sum > r, τότε sum − r is μεταφέρεται κ προστίθεται στο sum που 
υπολογίζεται για το επόμενο bin .Ο αλγόριθμος τερματίζει όταν δεν υπάρχουν άλλα 
αντικείμενα στο S. 
Οι Bin Packing αλγόριθμοι από των Eilon και Christofides, 1971 και Martello και 
Toth εξετάζουν τα στοιχεία εισόδου, ένα την φορά και τα τοποθετούν σε 
κάδους. Αντίθετα ,ο αλγόριθμος bin completion ελέγχει 
τους κάδους, ένα κάθε φορά και να αποδίδει ένα πλήρες σύνολο στοιχείων σε αυτούς. 

Ένας από τους καλούς αλγόριθμους για να βρούμε τη βέλτιστη λύση του binpacking 
problem μας δίνεται από τους Martello και Toth. Ο 
branch-and-bound αλγόριθμος τους είναι πολύπλοκος και θα περιγράψουμε μόνο τα 
κύρια σημεία του. Ο αλγόριθμος παίρνει τα αντικειμενική με φθίνουσα σειρά και 
τοποθετεί τα αντικείμενα με σειρά μέσα σε κάθε ημισυμπληρωμένο bin όπου χωράνε, 
και σε ένα νέο bin, διακλαδώνοντας σε αυτές τις 2 εναλλακτικές. Αυτό έχει ως 
αποτέλεσμα ο χώρος του προβλήματος να περιορίζεται στο n!, όπου το n είναι ο 
αριθμός τον αντικειμένων, αλλά αυτό είναι ένα <<κακό>> πάνω όριο, αφού πολλά 
αντικείμενα δεν θα χωρέσουν στο ίδιο bin όπως άλλα. Σε κάθε κόμβο του δέντρου 
αναζήτησης, οι Martello & Toth υπολογίζουν για τον firstfit, bestfit, και worstfit 
decreasing την πληρότητα για την κάθε αντίστοιχη μερική λύση. Μια μερική λύση στο 
binpacking problem είναι μια λύση όπου κάποια, αλλά όχι όλα, τα αντικείμενα έχουν 
ανατεθεί σε bins. Η πληρότητα μιας μερικής λύσης, παίρνει τα τρέχοντα μερικώς-
συμπληρωμένα bins, και αναθέτει τα υπόλοιπα, σε μη ανατεθειμένα αντικείμενα σε 
bins. Ο worstfit decreasing αλγόριθμος τοποθετεί κάθε διαδοχικό αντικείμενο στον 
ημισυμπληρωμένο bin με την μεγαλύτερη απομείνουμε χωρητικότητα που μπορεί να 
χωρέσει την αξία του αντικειμένου. Καθεμία από αυτές τις προσεγγιστικές λύση 
συγκρίνεται με το κάτω όριο στην εναπομείνασα λύση κ αποκαλείται L3. Το L3 όριο 
υπολογίζεται "χαλαρώνοντας" το υπολειπόμενο ψευδοπρόβλημα, αφαιρώντας το 
μικρότερο αντικείμενο και στη συνέχεια εφαρμόζοντας το L2 όριο σε κάθε μια από τις 
"χαλαρωμένες" περιπτώσεις, επιστρέφοντας το μεγαλύτερο κάτω όριο. Το όριο L2 
των Martello & Toth περιορίζει ισάξια το εκτιμώμενο wastedspace όριο που 
περιγράφτηκε παραπάνω, άλλα χρησιμοποιεί έναν πιο περίπλοκο αλγόριθμο για να το 
υπολογίσει. Αν ο αριθμός των bins που χρησιμοποιήθηκαν από οποιοδήποτε από τις 
προσεγγιστικές περατώσεις ισούται με το κάτω όριο για την συμπλήρωση της 
αντίστοιχης μερικής λύσης, κανένας παραπάνω έλεγχος δεν γίνεται κάτω απο αυτό τον 
κόμβο. Αν ο αριθμός των bins σε κάθε προσεγγιστική λύση ισούται με το κάτω όριο του 
αρχικού προβλήματος, ο αλγόριθμος τερματίζει επιστρέφοντας την λύση ως βέλτιστη. 
Η κύρια πηγή αποτελεσματικότητας του αλγόριθμο Martello & Toth είναι ότι μειώνει το 
μέγεθος των εναπομεινάντων υποπροβλημάτων, όπου θα συζητήσουμε παρακάτω στο 
κομμάτι “Σχέσεις Κυριαρχίας”. 

Μερικά σετ από αντικείμενα τοποθετημένα σε ένα bin οδηγούν εγγυημένα σε λύση 
τουλάχιστον το ίδιο καλή όσο αυτές που επιτυγχάνονταν τοποθετώντας άλλα σετ από 
αντικείμενα στο ίδιο bin. Θα ξεκινήσουμε με κάποια απλά παραδείγματα αυτών τον 
σχέσεων κυριαρχίας και στην συνέχεια θα πάμε στην γενικοποίηση τους. Αρχικά, έστω 
ότι έχουμε δύο στοιχεία x και y, τέτοια ώστε x+y = c, όπου c είναι η χωρητικότητα του 
bin. Υποθέτουμε ότι στην βέλτιστη λύση, τα x y είναι σε διαφορετικά bins. Σε αυτή την 
περίπτωση μπορούμε να ανταλλάξουμε το y με όλα τα άλλα αντικείμενα που 
βρίσκονται στο ίδιο bin με το w x, χωρίς να αυξήσουμε τον αριθμό των bins. Αυτό μας 
δίνει μια νέα βέλτιστη λύση με τα x και y στο ίδιο bin. Επομένως, δεδομένου ενός 
προβλήματος με δύο τιμές x και y τέτοιες ώστε x + y = c, μπορούμε πάντα να βάζουμε 
τα x και y στο ίδιο bin, με αποτέλεσμα ένα μικρότερο πρόβλημα. 
Δυστυχώς αυτό δεν επεκτείνεται σε 3 η περισσότερα αντικείμενα που το άθροισμά τους 
είναι ακριβώς ίσο με την χωρητικότητα του bin. 
Σαν ένα άλλο παράδειγμα, θεωρούμε ένα αντικείμενο x σαν το μικρότερο τέτοιο ώστε 
τα μικρότερα δύο (2) εναπομείναντα αντικείμενα προστιθέμενα στο x θα ξεπεράσουν το 
c. Δηλαδή το πολύ ένα επιπλέον αντικείμενο μπορεί να προστεθεί στο bin που 
βρίσκεται το x. Έστω ότι το y είναι το μεγαλύτερο εναπομείναν αντικείμενο τέτοιο ώστε 
x + y ≤ c. Τότε, βάζουμε το y στο ίδιο bin όπως το x χωρίς να χάνουμε ποιοτικά στη 
λύση μας. Ο λόγος είναι επειδή αν βάλουμε οποιοδήποτε άλλο αντικείμενο, έστω z, μαζί 
με το x, τότε θα μπορούσαμε να ανταλλάξουμε το y με το z, αφού z ≤ y και x + y ≤ c. 
Σαν τελευταίο παράδειγμα, ας υποθέσουμε ότι το y είναι το μεγαλύτερο από τα 
αντικείμενα που έχουν μείνει και μπορεί να προστεθεί στο x έτσι ώστε x+y ≤ c, 
υποθέτουμε ότι το y είναι ίσο η μεγαλύτερο του αθροίσματος οποιωνδήποτε σετ από τα 
εναπομείναντα αντικείμενα που μπορούν να προστεθούν στο x χώρις να ξεπερνούν το 
c. Σε αυτή την περίπτωση, μπορούμε πάλι να βάλουμε τα x και y στο ίδιο bin, χωρίς να 
χάνουμε από την ποιότητα της λύσης. Ο λόγος που συμβαίνει αυτό είναι ότι, 
οποιοδήποτε άλλο σετ από αντικείμενα που θα τοποθετούνταν στο ίδιο bin όπως το x 
θα μπορούσαμε να το ανταλλάξουμε με το y χωρίς να αυξήσουμε τον αριθμό των bins. 
Η γενική μορφή αυτής της σχέσης κυριαρχίας μας δίνεται από τους Martello & Toth. 
Ορίζουμε ένα εφικτό σύνολο, σαν ένα σύνολο από 
αντικείμενα των οποίων το άθροισμα δεν μπορεί να ξεπεράσει τη χωρητικότητα του 
bin. Με A και B να είναι δύο δυνατά σύνολα. Αν όλα τα αντικείμενα του B μπορούν να 
πακεταριστούν σε σετ bins των οποίων οι χωρητικότητες είναι αντικείμενα του A, τότε 
το σύνολο A κυριαρχεί του συνόλου B. Δεδομένων όλων τον δυνατών συνόλων που 
περιέχουν ένα κοινό αντικείμενο x, μόνο το κυριαρχών σύνολο χρειάζεται να να 
υπολογίζεται για ανάθεση στο bin που περιέχει x. Οι Martello & Toth χρησιμοποιούν αυτή 
την σχέση κυριαρχίας για να μειώσουν το μέγεθος των υποπροβλημάτων που 
προκύπτουν από την ερευνά τους. Δεδομένου ενός μερικώς λυμένου προβλήματος, 
όπου κάποια αντικείμενα έχουν ήδη ανατεθεί σε bins, οι Martello & Toth πρώτα 
μετατρέπουν το μερικώς λυμένο πρόβλημα σε ένα ισοδύναμο αρχικό πρόβλημα, όπου 
κανένα αντικείμενα δεν έχει ανατεθεί σε bin, σε δύο βήματα. Αρχικά, κάθε αντικείμενο 
που δεν έχει ανατεθεί, ή έχει ανατεθεί σε bin χωρίς άλλα αντικείμενα αφήνεται ως έχει. 
Εν συνεχεία, για κάθε bin που έχει παραπάνω από ένα αντικείμενο, όλα τα αντικείμενα 
που βρίσκονται σε αυτό αντικαθίστανται με ένα αντικείμενο ίσο με το άθροισμα τους, 
Εγκυόμενοι ότι κάθε ένα από τα αντικείμενα , που είχαν μπει στο ίδιο bin θα μείνουν 
μαζί. Για να μειωθεί το μέγεθος του προβλήματος, οι Martello & Toth παίρνουν κάθε 
αντικείμενο x με τη σειρά, ξεκινώντας με το μεγαλύτερο αντικείμενο, και ελέγχοντας να 
δουν αν υπάρχει αν υπάρχει μοναδικό σύνολο από τρία ή λιγότερα αντικείμενα, 
συμπεριλαμβανομένου του x, που να κυριαρχεί όλων των δυνατών συνόλων που 
περιλαμβάνουν το x. Εάν υπάρχει, βάζουν το x μαζί με αυτά τα αντικείμενα στο ίδιο 
bin, και αναδρομικά εφαρμόζουν τον ίδιο αλγόριθμο μείωσης για να φτάσουν σε 
μειωμένο πρόβλημα. Επίσης να χρησιμοποιούν τις σχέσεις κυριαρχίας για να 
περικόψουν κάποιες τοποθετήσεις των στοιχείων σε bins. 

O καλύτερος μέχρι στιγμής αλγόριθμος για binpacking, μας δίνεται από τον Korf 
που τον ονόμασε bin completion, ο αλγόριθμος αυτός κάνει ποιο 
αποδοτική τη χρήση των σχέσεων κυριαρχίας. Όπως ο αλγόριθμος Martello και Toth, 
ο bin completion είναι επίσης ένας αλγόριθμος διακλάδωσης και οριοθέτησης, αλλά 
ερευνά ένα διαφορετικό κομμάτι του προβλήματος. Αντί να εξετάζει κάθε στοιχείο με τη 
σειρά του, και να αποφασίζει σε ποιο κάδο θα το τοποθετήσει, ερευνά τον κάθε κάδο 
με τη σειρά του, και εξετάζει τα μη-κυριαρχούμενα εφικτά στοιχεία που θα μπορούσαν 
να χρησιμοποιηθούν για την συμπλήρωση αυτού του bin. Ταξινομεί τα στοιχεία με 
φθίνουσα σειρά μεγέθους, και να εξετάζει τους κάδους που περιέχουν κάθε στοιχείο με 
τη σειρά του, απαριθμώντας όλες τις μηκυριαρχούμενες συμπληρώσεις αυτού του bin, 
και τις διακλαδώσεις, αν υπάρχουν περισσότερες από μία. Με άλλα λόγια, πρώτα 
συμπληρώνει τον κάδου που περιέχει το μεγαλύτερο στοιχείο, στη συνέχεια να 
ολοκληρώσει τον κάδο που περιέχει το δεύτερο μεγαλύτερο στοιχείο, κλπ. 


Γενικά ο αλγόριθμος bincompletion δουλεύει ως εξής. Πρώτα υπολογίζουμε την λύση 
ΒFD. Στη συνέχεια υπολογίζουμε ένα κάτω όριο για το συνολικό πρόβλημα 
χρησιμοποιώντας το όριο του χαμένου χώρου (wastedspace) που αναφέραμε 
παραπάνω. Αν το κάτω όριο ισούται με τον αριθμό τον bins της λύσης BFD τότε αυτή 
ειναι η βέλτιστη λύση. Αλλιώς αρχικοποιούμε την καλύτερη λύση μέχρι στιγμής για τη 
λύση BFD και ξεκινάμε έναν έλεγχο διακλάδωσηςορίου αυστηρά για καλύτερες λύσεις. 
Μόλις οι μερικές/τμηματικές λύσεις χρησιμοποιούν τόσα bins όσα η βέλτιστη ολική λύση 
που έχει βρεθεί μέχρι στιγμής, κόβουμε τη διακλάδωση του ελέγχου. Μελετάμε τα 
αντικείμενα με φθίνουσα σειρά και φτιάχνουμε όλες τις μη-κυριαρχούμενες 
συμπληρώσεις του bin που περιέχει το εν λόγω αντικείμενο. Αν δεν υπάρχουν 
συμπληρώσεις ή υπάρχει μοναδική μη-κυριαρχούμενη συμπλήρωση, συμπληρώνουμε 
το bin με αυτήν, με αυτόν το τρόπο και πάμε στο bin που περιέχει το επόμενο 
αντικείμενο. Αν υπάρχουν παραπάνω από μια μη-κυριαρχούμενες συμπληρώσεις, τις 
διατάσσουμε σε φθίνουσα σειρά συνολικού μεγέθους και μελετάμε το μέγιστο που 
χωράει αφήνοντας τα άλλα ως πιθανά σημεία μελλοντικής διακλάδωσης. Όποτε 
βρίσκουμε μια πλήρης λύση καλύτερη, από την μέχρι στιγμής λύση, ανανεώνουμε την 
βέλτιστη μέχρι στιγμής λύση. 
Για ένα χαμηλότερο όριο για μια μερική λύση, χρησιμοποιούμε το άθροισμα όλων των 
στοιχείων, καθώς και τον χώρο που απομένει στα bins που συμπληρώθηκαν μέχρι 
στιγμής, διαιρούμενο με την χωρητικότητα των bin και στρογγυλοποιημένο στον 
επόμενο μεγαλύτερο ακέραιο αριθμό. Αντίστοιχα, μπορούμε να προσθέσουμε τον 
αριθμό των bins που συμπληρώθηκαν στο άθροισμα των υπολοίπων στοιχείων, 
διαιρεμένο με την χωρητικότητα του bin και στρογγυλοποιημένο προς τον πάνω 
ακέραιο. Αυτό το κάτω όριο είναι πιο αποτελεσματικό από ότι το εκτιμώμενο όριο 
χαμένου χώρου που περιγράφεται παραπάνω, επειδή συμπεριλαμβάνει την 
πραγματική σπατάλη χώρου στους συμπληρωμένους κάδους. Επιπλέον, υπολογίζεται 
σε σταθερό χρόνο, απλώς συσσωρεύοντας/αθροίζοντας τις ποσότητες σπαταλημένου 
χώρου στους συμπληρωμένους κάδους. Έτσι, μπορούμε να αντικαταστήσουμε ένα 
γραμμικού χρόνου κάτω όριο συνάρτησης, με μια πιο ακριβή συνάρτηση σταθερού 
χρόνου, χωρίς καμία απώλεια στην δυνατότητα κλαδέματος. Αν το κάτω όριο για μια 
μερική λύση ισούται ή υπερβαίνει τον αριθμό των κάδων στην καλύτερη λύση μέχρι 
στιγμής, κλαδεύουμε την εξέταση της εν λόγω μερική λύση. 
O περισσότερος χρόνος στον αλγόριθμό bincompletion δαπανάται στον 
υπολογισμό των μη-κυριαρχούμενων συμπληρώσεων ενός κάδου. Προκειμένου να 
γίνει πιο αποδοτικό δουλεύουμε ως εξής. Δεδομένου ενός στοιχείου x, βρίσκουμε 
πρώτα το μεγαλύτερο στοιχείο y για τα οποία x + y ≤ c . 
Στη συνέχεια υπολογίζουμε όλα τα εφικτά ζεύγη w και z, τέτοια ώστε x + w + z ≤ c , τα 
οποία είναι μηκυριαρχούμενα από κάθε μοναδικό y, δηλαδή w + z > y, και τέτοια ώστε 
κανένα ζεύγος να μην κυριαρχεί σε οποιοδήποτε άλλο. 
 Ας υποθέσουμε, χωρίς βλάβη της γενικότητας ότι d > f . Σε αυτήν την περίπτωση, το 
g πρέπει να είναι μεγαλύτερο από το e, ή d + e να κυριαρχήσει στο f + g . Έτσι, 
δεδομένων οποιωνδήποτε δύο ζευγών στοιχείων, όπου κανένα ΔΕΝ κυριαρχεί το άλλο , 
το ένα πρέπει να εντελώς φωλιασμένο μέσα στο άλλο σε ταξινομημένη σειρά. 
Μπορούμε να δημιουργήσουμε όλα αυτά τα μηκυριαρχούμενα ζεύγη σε γραμμικό 
χρόνο, κρατώντας όλα τα υπόλοιπα στοιχεία ταξινομημένα, έχοντας δυο δείκτες 
(pointers) πάνω στην λίστα,ένα δείκτη σε ένα μεγαλύτερο στοιχείο και ένα δείκτη σε ένα 
μικρότερο. Εάν το άθροισμα των δύο στοιχείων υπερβαίνει τη χωρητικότητα του bin , θα 
μετατοπίσουμε τον μεγαλύτερο δείκτη προς τα κάτω στο αμέσως επόμενο μικρότερο 
στοιχείο. Εάν το άθροισμα των δύο (δικτούμενων) στοιχείων είναι μικρότερο ή ίσο με το 
y, μετατοπίσουμε το μικρότερο δείκτη στον αμέσως μεγαλύτερο στοιχείο. Εάν καμία από 
αυτές τις περιπτώσεις δεν συμβεί, έχουμε ένα μηκυριαρχούμενο ζευγάρι, και θα 
μετατοπίσουμε το μεγαλύτερο δείκτη προς τα κάτω, και το μικρότερο δείκτη επάνω. 
Σταματάμε όταν οι δείκτες φτάσουν ο ένας τον άλλον. 
Μετά τον υπολογισμό όλων των μηκυριαρχούμενων ζευγών συμπλήρωσης, 
μπορούμε στη συνέχεια να υπολογίσει όλες τις τριάδες d, e , f και, έτσι ώστε 
x + d + e + f ≤ c και d + e + f > y, μετά όλες τις τετράδες , κλπ. 
Για να υπολογίσουμε όλες τις τριάδες, επιλέγουμε κάθε 
εφικτό πρώτο στοιχείο, και στη συνέχεια, χρησιμοποιούμε όλα τα μηκυριαρχούμενα 
ζεύγη για τα υπόλοιπα δύο στοιχεία. Για όλες τις τετράδες, επιλέγουμε όλα τα πιθανά 
ζεύγη, τότε χρησιμοποιήστε όλα τα μη-κυριαρχούμενα ζεύγη για τα υπόλοιπα δύο 
στοιχεία , κλπ. Αυτά τα μεγαλύτερα εφικτά σύνολα, θα περιλαμβάνουν κυριαρχούμενα σύνολα σε γενικές γραμμές. 
Δεδομένων δύο εφικτών συνόλων, ο καθορισμός του, εάν το μεγαλύτερο άθροισμα 
κυριαρχεί του άλλου είναι ένα άλλο ένα πρόβλημα bin packing. Αυτό το πρόβλημα είναι 
συνήθως τόσο μικρό που το λύσουμε άμεσα με bruteforce search. 

Ένα ενδιαφέρον πρόβλημα για μελέτη παράλληλα με το BPP είναι αυτό του 
MapReduce, καθώς βασικοί αλγόριθμοι του bin packing χρησιμοποιούνται για την 
εύρεση προσεγγιστικής λύσης του MapReduce. Ενώ αντίστροφα, οι αλγόριθμοι που 
χρησιμοποιούνται στο πρόβλημα του MapReduce, μας δίνουν ταυτόχρονα λύση σε 
συγκεκριμένες εκδοχές του Bin Packing. Παρακάτω θα δούμε τι είναι εν γένει το 
MapReduce και σε ποιες περιπτώσεις του Bin Packing μπορεί να μας είναι χρήσιμο. 

Το MapReduce είναι ένα σύστημα προγραμματισμού που χρησιμοποιείται για 
παράλληλη επεξεργασία των δεδομένων μεγάλης κλίμακας. Έχει δύο φάσεις, τη φάση 
χαρτογράφησης (Μapping Schema) και τη φάση μείωσης. Τα δεδομένα εισόδου 
επεξεργάζονται από την φάση χαρτογράφησης που ορίζετε από τον χρήστη για να 
παράγουν ενδιάμεσα δεδομένα (της μορφής key, value). Τα ενδιάμεσα δεδομένα, στη 
συνέχεια , υποβάλλονται σε επεξεργασία από τη φάση μείωσης που εφαρμόζει μια 
συνάρτηση οριζόμενη από το χρήστη στα κλειδιά και στις σχετικές τιμές τους. 
Το τελικό αποτέλεσμα παρέχεται από την φάση μείωσης 
Ένας αλγόριθμος MapReduce μπορεί να περιγραφεί από ένα σχήμα χαρτογράφησης, 
η οποία αποδίδει τις εισόδους σε ένα σύνολο από reducers, έτσι ώστε για κάθε 
απαιτούμενη έξοδο να υπάρχει ένας reducer που λαμβάνει υπόψιν όλες τις εισόδους 
που συμμετέχουν στον υπολογισμό της η εξόδου αυτής. Ωστόσο, μεμονωμένες 
είσοδοι μπορεί να διαφέρουν όσον αφορά το μέγεθος τους. Το κόστος επικοινωνίας 
μπορεί να βελτιστοποιηθεί με την ελαχιστοποίηση του αριθμού αντιγράφων των 
εισόδων που αποστέλλονται στους reducers. Το κόστος επικοινωνίας είναι στενά 
συνδεδεμένο με τον αριθμό των reducers συγκεκριμένης περιεκτικότητας που 
χρησιμοποιούνται για να φιλοξενήσει τις εισόδους. 
Στο MapReduce συναντάμε δύο βασικές οικογένειες προβλημάτων. Μία οικογένεια 
προβλημάτων δυο διαφορετικών συνόλων Χ και Υ όπου κάθε στοιχείο του συνόλου Χ 
πρέπει να τοποθετηθεί σε reducer με όλα τα στοιχεία του συνόλου Υ, γνωστή ως Χ2Υ, 
που σχηματικά μπορεί να αναπαρασταθεί με ένα γράφο. Και μία άλλη οικογένεια 
προβλημάτων όπου απαιτείται ότι η κάθε εισόδος συναντά τις υπόλοιπες εισόδους σε 
ένα τουλάχιστον reducer, η οποία είναι γνωστή ως all2all περίπτωση συμβολιζόμενη 
ως A2A. Σχηματικά αυτό μπορούμε να το προσομοιάσουμε με μια κλίκα όπου κάθε 
σημείο της πρέπει να πακεταριστεί τον ίδιο reducer με κάθε ένα από τα στοιχεία που 
επικοινωνεί τουλάχιστον μία φορά, πράγμα ταυτόσημο με το bin packing σε κλίκα. 

Ένα σημαντικό μέτρο απόδοσης για αλγορίθμους MapReduce είναι η ποσότητα των 
δεδομένων που μεταφέρονται από τους χαρτογράφους (οι διαδικασίες όπου εφαρμόζεται 
η λειτουργία χαρτογράφησης) στους reducers (οι διαδικασίες που εφαρμόζουν τη 
λειτουργία μείωσης). Αυτό ονομάζεται κόστος επικοινωνίας 
Ορίζουμε χωρητικότητα reducer να είναι το ανώτατο όριο μεγέθους αξιών που μπορεί 
να εκχωρηθεί στον reducer. Στα πλαίσια αυτής της εργασίας θεωρούμε ότι όλοι οι 
reducer έχουν την ίδια χωρητικότητα. 
Οι ακόλουθες σχέσεις εμφανίζονται σε αλγόριθμους MapReduce .
Μια αντίστροφη σχέση μεταξύ της χωρητικότητας reducer και τον συνολικό αριθμό των 
reducer. Για παράδειγμα, μεγάλης χωρητικότητας reducer επιτρέπει τη χρήση ενός 
μικρότερου αριθμού reducers. Μια αντίστροφη σχέση μεταξύ της χωρητικότητας reducer 
και τον παραλληλισμό. Για παράδειγμα, αν θέλουμε να επιτύχουμε υψηλό βαθμό 
παραλληλισμού, θέλουμε χαμηλής χωρητικότητας reducers. Μια αντίστροφη σχέση 
μεταξύ της χωρητικότητας reducer και το κόστος επικοινωνίας. Για παράδειγμα, στην 
περίπτωση που η χωρητικότητα του reducer είναι ίση με το συνολικό μέγεθος των 
δεδομένων, τότε μπορούμε να χρησιμοποιήσουμε ένα reducer και να έχουν το ελάχιστο 
κόστος επικοινωνίας (φυσικά, αυτό πηγαίνει σε βάρος του παραλληλισμού). 
Το Μapping Schema είναι ένα σχήμα χαρτογράφησης όπου συμβαίνει η εκχώρηση του 
συνόλου των εισόδων σε reducers, έτσι ώστε οι ακόλουθοι δύο περιορισμοί να 
ικανοποιούνται: 
α) Σε κάθε reducer έχουν ανατεθεί είσοδοι των οποίων το άθροισμα των μεγεθών είναι 
μικρότερο ή ίσο με τη χωρητικότητα του reducer q. 
β) Για κάθε έξοδο, πρέπει να εκχωρηθούν οι αντίστοιχες είσοδοι του σε τουλάχιστον 
ένα κοινό reducer. 
Ένα σχήμα χαρτογράφησης είναι βέλτιστο όταν το κόστος επικοινωνίας είναι ελάχιστο. 
Ο αριθμός των reducers που χρησιμοποιούμε συχνά είναι ελάχιστος για ένα βέλτιστο 
σχήμα χαρτογράφησης , αλλά αυτό δεν είναι πάντα το ζητούμενο . Είναι επιθυμητό να 
ελαχιστοποιείται και το μέγεθος του reducer επίσης. Το μέγεθος των reducers όπως 
αναφέραμε και νωρίτερα είναι σταθερό στα πλαίσια αυτής της μελέτης, αν διαιρέσουμε 
τόσο τη χωρητικότητα του reducer q όσο και τα μεγέθη των εισόδων με το μέγεθος q , 
μπορούμε να δούμε τους reducers ως bins μεγέθους 1 (ένα) και τις εισόδους ως 
στοιχεία προς εισαγωγή σε αυτά τα bins. 
2.5.3 Αλγόριθμοι για το Mapping Schema 
Έχει αποδειχθεί το το Mapping Schema είναι NP -hard τόσο για την Α2Α όσο και για 
την Χ2Υ περίπτωση. Δεδομένου ότι το πρόβλημα A2A Mapping Schema είναι NP-hard, 
ψάχνουμε για ειδικές περιπτώσεις και αναπτύσσουμε αλγόριθμους για την λύση 
τους. Υπάρχοντες αλγόριθμοι βασίζονται στον bin packing, την επιλογή πρώτου 
αριθμού p και την κατανομή των εισροών σε δύο ομάδες με βάση τα μεγέθη τους. Οι α 
προσεγγιστικοί αλγόριθμοι έχουν δύο περιπτώσεις, ανάλογα με τα μεγέθη των εισόδων, 
ως εξής: 
1. Είσοδος μεγεθών ≤ q/2 
2. Μία είσοδος είναι του μεγέθους wi, μεγαλύτερο από το q/2, αλλά μικρότερο από το q, 
και όλες οι άλλες εισροές έχουν μέγεθος μικρότερο ή ίσο με q-wi. Στην περίπτωση 
αυτή, το μεγαλύτερο μέρος του κόστους επικοινωνίας προέρχεται από την προσπάθια 
αντιστοίχισης της μεγάλης εισόδου με κάθε άλλη είσοδο. 
Φυσικά, αν οι δύο μεγαλύτερες είσοδοι είναι μεγαλύτερες από το δεδομένο reducer 
χωρητικότητας q , τότε δεν υπάρχει λύση για το πρόβλημα σχήμα χαρτογράφησης Α2Α 
επειδή αυτές οι δύο είσοδοι δεν μπορουν να ανατεθούν σε ένα μόνο κοινό. 
Παράμετροι για ανάλυση. Αναλύουμε τους προσεγγιστικούς αλγόριθμους για το 
Mapping Schema ανάλογα με τις ακόλουθες παραμέτρους: 
1. Αριθμός reducers. Αυτός είναι ο αριθμός των reducers που χρησιμοποιείται από το 
σχήμα χαρτογράφησης για να στείλουμε όλες τις εισόδους 
2. Το κόστος της επικοινωνίας, c. Το κόστος επικοινωνίας ορίζεται ως το άθροισμα 
όλων των bits που απαιτούνται, σύμφωνα με το σχήμα χαρτογράφησης, 
να μεταφέρει από τη φάση χαρτογράφησης στη φάση μείωσης. 
Χρησιμοποιούμε ένα γνωστό αλγόριθμο bin packing να τοποθετήσει τις εισόδους m 
σε κάδους μεγέθους q/k. Ας υποθέσουμε ότι χρειαζόμαστε x κάδους για να 
τοποθετήσετε εισόδους m. Τώρα, κάθε ένας από αυτους τους κάδους θεωρείται ως μια 
ενιαία είσοδος του μεγέθους q/k για το πρόβλημά μας εύρεσης ενός βέλτιστου σχήματος 
χαρτογράφησης. Φυσικά, η παραδοχή είναι ότι όλες οι είσοδοι είναι μεγέθους το πολύ 
q/k. Οι FFD και BFD είναι οι πιο αξιοσημείωτοι αλγόριθμοι bin packing. Για παράδειγμα, 
ας δούμε την περίπτωση k=2. Στην περίπτωση αυτή, δεδομένου ότι η χωρητικότητα 
κάθε reducer είναι q, κάθε δύο κάδοι μπορουν να ανατεθούν σε ένα μόνο reducer. Ως 
εκ τούτου, ο αλγόριθμος προσέγγισης χρησιμοποιεί το πολύ x (x1)/2 reducers. 
Από τη στιγμή που απαιτούνται το πολύ x (x1)/2 reducers για μια λύση στο πρόβλημα 
χαρτογράφησης A2A, ο αλγόριθμος απαιτεί το πολύ (11/9 OPT)2/ 2 reducers. Να 
σημειωθεί ότι, σε αυτή την περίπτωση, το OPT δεν δείχνει το βέλτιστο αριθμό απο 
reducers που ικανοποιούν το πρόβλημα A2A Μapping Schema. Το OPT δείχνει το 
βέλτιστο αριθμό των κάδων μεγέθους q/2 που απαιτούνται για να τοποθετήθουν οι m 
είσοδοι. 
 
Όπως εξηγήσαμε παραπάνω, να ψάχνουμε για εισόδους του ίδιου μεγέθους είναι 
λογικό, διότι οι είσοδοι μέσω του bin packing τοποθετούνται σε κάδους του μεγέθους 
q/k, για k>=2, και μόλις γίνει αυτό, μπορούμε να μεταχειριστούμε τους ίδιους τους 
κάδους ως εισόδους που θα σταλθούν στους reducers. Οπότε μπορούμε να δούμε τη 
χωρητικότητα του reducer ως έναn πραγματικό αριθμό 
Αναδρομικοί αλγόριθμοι, που όχι μόνο εξασφαλίζουν το όριο r ≤ ( m1 )m/q1 αλλά το 
κάνουν με τρόπους που χωρίζουν τους reducers σε «ομάδες» τ, όπου κάθε ομάδα έχει 
ακριβώς μία εμφάνιση της κάθε εισόδου, μας δίνονται από τους στο Aftati Ulman,συμβολιζόμενοι ΑU 
Έχουν αποδείξει ότι με αυτούς τους αλγόριθμους μπορούμε να έχουμε βέλτιστα 
mapping schemas για τις εξής περιπτώσεις: 
1. q = 2 
2. q = 3 
3. q να είναι πρώτος και m = q2 
4. q1 να είναι πρώτος και m = (q1)2 +q 
Ενώ οι αλγόριθμοι αυτοί χωρίς να δίνουν βέλτιστα mapping schemas δίνουν καλά 
προσεγγιστικά αποτελέσματα και για τις υπολοιπές περιπτώσεις 
Σε αυτή την ενότητα, παρέχουμε τους δύο αλγορίθμους για σχεδόν ίσου μεγέθους (q/k, 
όπου k> 1) εισόδους, για να εισέλθει κάθε ζεύγος εισόδων σε reducers χωρητικότητας 
q. Με άλλα λόγια, μας δίνονται πολλές είσοδοι μικρού μεγέθους σε σύγκριση με το q, 
εμείς πακετάρουμε τις εισόδους σε κάδους σταθερού μεγέθους της και στη συνέχεια να 
εξετάζουμε τον κάθε κάδο ως ενιαία είσοδο. 
Οι δύο αλγόριθμοι μπορούν να συνοψιστούν ως εξής: Αλγόριθμοι 2 βημάτων 
(Αλγόριθμος 1 και Αλγόριθμος 2) πρώτα χειρίζονται τις εισόδους ώστε να οδηγηθούν σε 
σταθερά μεγέθη και στην συνέχεια κάθε ένας από τους αλγόριθμους, αναλαμβάνει 
ανάλογα αν οi reducers μπορεί να χωρέσει άρτιο ή περιττό αριθμό εισόδων. Οι 
αλγόριθμοι 1 και 2 χρησιμοποιούνται όταν το q είναι ένας άρτιος ή περιττός αριθμός 
αντίστοιχα. 
Στόχος μας είναι να χρησιμοποιήσουμε τους Αλγόριθμους 1, 2 και να ελαχιστοποιηθεί 
το κόστος της επικοινωνίας μεταξύ της φάσης χαρτογράφησης και της φάσης μείωσης για 
ένα δεδομένο αριθμό εισόδων και reducers χωρητικότητας q. 
Αλγόριθμος 1: Αλγόριθμος 2 βημάτων: όταν η χωρητικότητα του reducer q είναι ένας 
περιττός αριθμός. Για χάρη της κατανόησης και της παρουσίασης, παρουσιάζουμε ως 
παράδεγμα, reducer με q = 3, δηλαδή, ένα reducer μπορεί να κρατήσει το πολύ τρεις 
εισόδους. Ακολουθώντας το παράδειγμα δίνεται για q=3 , παρουσιάζουμε τον 
αλγόριθμό μας που χειρίζεται κάθε περιττή τιμή του q. Ο αλγόριθμος αποτελείται από τα 
πέντε παρακάτω στάδια: 

Αλγόριθμος 2: Ο αλγόριθμος 2 βημάτων, για όταν η χωρητικότητα reducer q είναι ένας 
άρτιος αριθμός. Σας παρουσιάζουμε τον αλγόριθμο (βλέπε Αλγόριθμος 2) που 
χειρίζεται κάθε άρτια τιμή του q. Για χάρη της κατανόησης και παρουσίαση, 
παρουσιάζουμε πρώτα ένα παράδειγμα όπου q = 4, δηλαδή η περίπτωση κατά την 
οποία ένας reducer μπορεί να κρατήσει το πολύ τέσσερις εισόδους, όπως 
καταδεικνύεται στο σχήμα. Σημειώστε ότι σε αντίθεση με τον αλγόριθμο για περιττές 
τιμές του q (Αλγόριθμος 1) ο αλγόριθμος για άρτιες τιμές των q (Αλγόριθμος 2) δεν 
διαιρεί τις εισόδους m σε δύο ομάδες. Ο αλγόριθμος αποτελείται από δύο βήματα, ως 
εξής: 

Σε αυτό το σημείο θα μελετήσουμε μια διαφορετική εκδοχή του Bin Packing Problem 
προερχόμενη από τον προβληματισμό που έρχεται από το MapReduce στην 
περίπτωση που θέλουμε τα διαδοχικά στοιχεία xi, xi+1 να συμπεριληφθούν στον ίδιο 
reducer ,όπου οι reducers είναι δεδομένης χωρητικότητας C και θέλουμε την χρήση όσο 
τον δυνατόν λιγότερων reducers. Το πρόβλημα αυτό σε αναλογία με το BPP 
διαμορφώνεται ως εξής: δεδομένων κάδων με χωρητικότητα C και αντικειμένων xi 
βάρους wi, να βρεθεί ο αριθμός των κάδων που απαιτούνται προκειμένου να 
τοποθετηθούν όλα τα αντικείμενα σε κάδους με τρόπο τέτοιο ώστε το άθροισμα των 
βαρών τον αντικειμένων σε κάθε κάδο να μην ξεπερνά το C και κάθε xi, xi+1 να είναι 
τοποθετημένα σε ίδιο κάδο. Κάθε αντικείμενο μπορεί να τοποθετηθεί σε παραπάνω από 
ένα κάδο. 

Θα ακολουθήσουμε το ίδιο σκεπτικό με τον NextFit για το κλασικό πρόβλημα, με την 
μόνη διαφορά να βρίσκεται όταν συμπληρώνεται ένα bin. Είναι προφανές ότι όταν η 
χωρητικότητα κάποιου bin yi συμπληρωθεί με ένα αντικείμενο xi με τέτοιο τρόπο ώστε 
να το xi+1 να μην χωράει στο yi , για να έχουμε xi και xi+1, θα πρέπει να τοποθετήσουμε 
το xi και στο bin yi αλλά και στο bin yi+1 . 

Για παράδειγμα έστω ότι έχουμε bin χωρητικότητας 10 και πρέπει να τοποθετήσουμε 
σε αυτά τα εξής αντικείμενα: 
Τοποθετώντας στον πρώτο κάδο θα φτάναμε στο σημείο 1,3,4,2 και θα είχαμε προς 
τοποθέτηση το 5, επειδή το 5 δεν χώρα στο ίδιο κάδο, θα ξαναβάλουμε το 2 και στον 
2ο κάδο παίρνοντας ως αποτέλεσμα: 
Στη συνέχεια δεν χωράει το 4 ,οπότε επαναλαμβάνεται το 5 στον 3ο BIN και πάει 
λέγοντας, έχοντας ως αποτελέσματα τελικά 
Για να συμπληρώσουμε τους κάδους στην παραπάνω περίπτωση, ξεκινήσαμε από το 
πρώτο στοιχείο και βάζαμε διαδοχικά τα επόμενα στοιχεία, χρησιμοποιώντας 
ουσιαστικά ένα αλγόριθμο NextFit. 
Συνοψίζοντας σε βήματα: 
ΒΗΜΑ 1ο 
Ξεκινώντας από τον πρώτο κάδο κ το πρώτο αντικείμενο x1, βάζουμε το αντικείμενο 
στον κάδο και συνεχίζουμε προσπαθώντας να βάλουμε το επόμενο x1+1 έως ότου 
φτάσουμε στο σημείο να μπει στον κάδο το τελευταίο αντικείμενο xn κ να μην χωράει το 
αντικείμενο xn+1 
ΒΗΜΑ 2ο 
Περνούμε νέο κάδο με πρώτο νέο στοιχείο, το τελευταίο στοιχείο (έστω xn) του 
προηγούμενου κάδου κ συνεχίζουμε εισάγοντας το xn+1 και πάει λέγοντας έως ότου δεν 
χωράει άλλο στοιχείο στον κάδο 
ΒΗΜΑ 3ο 
Επαναλαμβάνουμε το βήμα 2ο έως ότου να τοποθετηθούν όλα τα αντικείμενα σε 
κάδους. Ο τερματισμός έρχεται με το τελευταίο αντικείμενο xΤ. Ο αριθμός των κάδων 
που χρησιμοποιήθηκαν είναι η απάντηση του αλγορίθμου στο πρόβλημα 
Σε σχέση με τον NextFit στο από Bin Packing Problem εδώ βλέπουμε να 
επαναλαμβάνεται ουσιαστικά ένα στοιχείο από κάθε κάδο στον επόμενο και 
συγκεκριμένα το τελευταίο στοιχείο κάθε κάδου. 

Πριν ξεκινήσουμε την παρουσίαση του αλγορίθμου, καλό είναι να δούμε το κίνητρο 
που οδήγησε στην σύλληψη του, καθώς και τα χαρακτηριστηκά των αντικειμένων προς 
εισαγωγή. Βάζοντας αντικείμενα σε κάδους, ώστε τα διαδοχικά αντικείμενα να 
βρίσκονται στον ίδιο κάδο, περνούμε ως αποτέλεσα το τελευταίο στοιχείο ενός κάδου, 
να είναι ταυτόχρονα το πρώτο του επόμενου. Στην προσπάθεια μας να έχουμε όσο το 
δυνατόν μικρότερο αυτό το στοιχείο, θα ξεκινάμε από το μεγαλύτερο δυνατό 
αντικείμενο, από άποψη βάρους, κινούμενη αριστερά δεξιά εναλλάξ, όπως θα 
αναλύσουμε παρακάτω. 
Όσον αφορά τα χαρακτηριστικά των αντικειμένων για το συγκεκριμένο πρόβλημα, θα 
μπορούσαμε να πούμε ότι έχει δύο κύρια το βάρος και την κατάσταση, όπου η 
κατάσταση χωρίζεται σε δύο επιπλέον, την κατάσταση της δεξιάς και της αριστερης 
πλευράς. Το βάρος W είναι σαν το απλό BPP. Η κατάσταση μας δείχνει αν η 
τοποθέτηση του αντικειμένου σε κάδο (ή κάδους) έχει ολοκληρωθεί. Καλό είναι σε αυτό 
το σημείο να θυμηθούμε ότι κάθε αντικείμενο πρέπει να μπει στον ίδιο κάδο με το 
προηγούμενο του, αλλά και σε ίδιο κάδο με το επόμενο. 
Οπότε η κατάσταση κάθε αντικειμένου έχει με την σειρά της δυο χαρακτηριστικά, την 
αριστερή πλευρά LS και την δεξιά πλευρά RS. Το πρώτο αντικείμενο X1 έχει την LS 
τοποθετημένη και το τελευταίο αντικείμενο Χn έχει την RS τοποθετημένη ενώ όλες οι 
άλλες πλευρές είναι προς τοποθέτηση εξ ορισμού τους. Η LS του Xk είναι η RS του Xk1 
και η RS του Xk είναι η LS του Χk+1. Όταν η δεξιά πλευρά RS ενός αντικείμενου έχει 
τοποθετηθεί, τότε το αντικείμενο αυτό δεν μπορεί να πραγματοποιήσει πλέον έλεγχο, 
για προς εισαγωγή αντικείμενο στον δεξιό του αντικείμενο (προφανώς το αντικείμενο 
στα δεξιά του είναι ήδη σε κάδο και μάλιστα στον ίδιο κάδο), άλλα ούτε μπορεί να 
εισέλθει σε άλλο κάδο από έλεγχο που πραγματοποιείται για προς εισαγωγή 
αντικείμενα προχωρώντας βήματα προς τα αριστερά. 

Έχοντας αυτά αποσαφηνισμένα μπορούμε να προχωρήσουμε στην παρουσίαση του 
αλγορίθμου. Ξεκινώντας από το μεγαλύτερο, από άποψη βάρους αντικείμενο, και τον 
πρώτο κάδο, ελέγχουμε για εισαγωγή το πρώτο δεξιά αντικείμενο και στη συνέχεια το 
πρώτο από τα αριστερά, δηλαδή αν το Χκ έχει το maxW ελέγχουμε για εισαγωγή 
πρώτα το Χκ+1 και στην συνέχεια το Χκ1. Η σειρά πρώτα δεξιά και στην συνέχεια 
αριστερά επιλέχθηκε εντελώς αυθαίρετα. Αν το Χκ+1 μπορεί να μπει στον κάδο η RS 
του Χκ και η LS του Χκ+1 αλλάζουν την κατάσταση τους σε τοποθετημένες και ο 
έλεγχος προς τα δεξιά περνά στο Χκ+1. Στη συνέχεια ελέγχει το στοιχείο αριστερά του 
Χκ δηλαδή το Χκ1. Αν μπορεί να μπει στον κάδο η LS του Χκ και η RS του Χκ1 
αλλάζουν κατάσταση σε τοποθετημένες και ο έλεγχος πρως τα αριστερά περνά στο Χκ-1. 
Αυτό συνεχίζεται έως ότου δεν μπορούμε να τοποθετήσουμε το επόμενο αντικείμενο. 
Έστω ότι δεν μπορούμε να τοποθετήσουμε το επόμενο αντικείμενο προς τα δεξιά, 
σταματάμε τον έλεγχο προς τα δεξιά και συνεχίζουμε προς τα αριστερά και μόνο. Όταν 
σταματήσει ο έλεγχος και προς τα αριστερά, έχουμε ένα ολοκληρωμένο κάδο. 
Δημιουργούμε τον επόμενο κάδο διαλέγοντας το μεγαλύτερο διαθέσιμο από άποψη W 
αντικείμενο το τοποθετούμε στον κάδο και επαναλαμβάνουμε το ίδιο, έως ότου να μην 
υπάρχει διαθέσιμο αντικείμενο. Αν το αντικείμενο που διαλέξαμε είναι διαθέσιμο αλλά η 
μια του πλευρά είναι τοποθετημένη πχ. η LS τότε θα πραγματοποιήσει έλεγχο μόνο ως 
προς την άλλη πλευρά, την δεξιά για το παράδειγμά μας. 
Για να κρίνουμε αν ένα αντικείμενο μπορεί να μπει σε ένα κάδο όπως πρέπει να είναι 
πλέων αντιληπτό, δεν εξαρτάται αποκλειστικά από το W, αλλά πρώτα από όλα από το 
αν είναι διαθέσιμη για έλεγχο η κάθε πλευρά του. Για την LS του προς εισαγωγή 
αντικείμενου ,ο έλεγχος από τα αριστερά , θα είναι έλεγχος δεξιάς πλευράς σε σχέση με 
το αντικείμενο που την πραγματοποιεί (άλλα κ το πρώτο αντικείμενο που μπήκε στον 
κάδο) και αντίστροφα για την RS. Αν το αντικείμενο μπορεί να ελεγχθεί για εισαγωγή, 
θα μπει η δεν θα μπει ανάλογα με το βάρος του W. Αν μπει θα αυξήσει στην πληρότητα 
του κάδου κατά W και το αντικείμενο αυτό θα αποτελέσει το επόμενο σημείο ελέγχου. 
Αν δεν μπει, σταματάει ο έλεγχος προς αυτή την πλευρά και συνεχίζει αποκλειστικά 
προς την άλλη, το τελευταίο αντικείμενο που μπήκε προς αυτή την πλευρά είναι η μια 
άκρη του κάδου. 
Αν έχουν προκύψει κάδοι συμπληρωμένοι κατά λιγότερο από το μισό, τους 
αντιμετωπίζουμε σαν ενιαία αντικείμενα και εφαρμόζουμε σε αυτά τον αλγόριθμο FFD. 
Θα μπορούσαμε να συνοψίσουμε τα παραπάνω στα εξής βήματα:
ΒΗΜΑ 1ο 
Ταξινομούμε τα αντικείμενα σε λίστα με φθίνουσα σειρά με βάση το βάρος W κάθε 
αντικειμένου 
ΒΗΜΑ 2ο 
Περνούμε ένα νέο κάδο και βάζουμε το μέγιστο στοιχείο της λίστας Xi που έχει 
τουλάχιστον μια πλευρά μην τοποθετημένη σε κάδο 
ΒΗΜΑ 3ο 
Προσπαθούμε να βάλουμε τα διαθέσιμα δεξιά, αριστερά αντικείμενα στον κάδο 
κινούμενοι δεξιά, αριστερά εναλλάξ 
α) για κάθε αντικείμενο δεξιά (Χi+1) που μπορεί να μπει στον κάδο (δεν είναι ήδη 
τοποθετημένη η αριστερή του πλευρά κ το W του είναι μικρότερο της υπολειπόμενης 
χωρητικότητας του κάδου) το τοποθετούμε (θέτουμε την αριστερή πλευρά του (Χi+1) ως 
τοποθετημένη όπως και τη δεξιά του (Χi) και στην επόμενη φορά ελέγχουμε το δεξιά 
αυτού (Χi+2). Όταν κάποιο στοιχείο δεν μπορεί να μπει σταματάμε τον έλεγχο προς τα 
δεξιά. 
β) για κάθε αντικείμενο αριστερά (Χi1) που μπορεί να μπει στον κάδο (δεν είναι ήδη 
τοποθετημένη η δεξιά του πλευρά κ το W του είναι μικρότερο της υπολειπόμενης 
χωρητικότητας του κάδου) το τοποθετούμε (θέτουμε την δεξιά πλευρά του (Χi1) ως 
τοποθετημένη όπως κ την αριστερή του (Χi)) και στην επόμενη φορά ελέγχουμε το 
αριστερά αυτού (Χi2). Όταν κάποιο στοιχείο δεν μπορεί να μπει σταματάμε τον έλεγχο 
προς τα αριστερά. 
ΒΗΜΑ 4ο 
Όταν σταματήσει ο έλεγχος αριστερά και δεξιά ο κάδος έχει ολοκληρωθεί και ξεκινάμε 
το γέμισμα νέου κάδου επαναλαμβάνοντας τα βήματα 2,3 έως ότου να μην υπάρχει 
άλλο αντικείμενο στην λίστα. Αν δεν υπάρχει αντικείμενο στη λίστα, οι κάδοι που 
δημιουργήθηκαν είναι το αποτέλεσμα της λύσης μας. 
ΒΗΜΑ 5ο 
Αν έχουν προκύψει κάδοι συμπληρωμένοι κατά λιγότερο από το μισό, τους 
αντιμετωπίζουμε σαν ενιαία αντικείμενα και εφαρμόζουμε σε αυτά τον αλγόριθμο FFD. 

Ένας άλλος αλγόριθμος που μπορεί να χρησιμοποιηθεί για τη λύση του 
προβλήματος είναι να δούμε τα διαδοχικά αντικείμενα σαν ένα αντικείμενο με βάρος το 
άθροισμα των βαρών τους και εν συνεχεία να εφαρμόσουμε στο αποτέλεσμά τους έναν 
από τους αλγορίθμους του κλασικού bin packing κατά βούληση. Πακετάροντας όλα τα 
διαδοχικά xn, xn+1 παίρνοντας ουσιαστικά το βάρος της πλευράς n που ενώνει τα xn, 
xn+1. Το αρνητικό της λύσης είναι ότι όλα τα βάρη πλην του βάρους του πρώτου και το 
τελευταίου αντικείμενου θα επαναληφθούν. Το θετικό είναι ότι από την στιγμή που θα 
έχουμε τα βάρη προς τοποθέτηση έως ζευγάρια μπορούμε να χρησιμοποιήσουμε ήδη 
γνωστούς αλγορίθμους για τη λύση του προβλήματος. 

Ένας ακόμα τρόπος προσεγγιστικής επίλυσης του προβλήματος είναι να χειριστούμε 
διαφορετικά τα ζευγάρια που προκύπτουν. Ξεκινώντας το ταίριασμα των αντικειμένων 
για κάθε xn, xn+1, θα τα μεταχειριστούμε διαφορετικά ανάλογα με το άθροισμα των 
βαρών τους. Αν wxn + wxn+1 ≥ c/2 θα τα τοποθετήσουμε σε ένα κάδο και θα 
συνεχίσουμε με NextFit αλγόριθμο προσπαθώντας να τοποθετήσουμε όσο το δυνατόν 
περισσότερα αντικείμενα, προσπαθώντας να φτιάξουμε ένα όσο το δυνατών πιο 
συμπληρωμένο κάδο, όταν φτάσουμε κάποιο αντικείμενο που δεν χωρά να εισέλθει 
ξεκινάμε νέο έλγχο μεταξύ του τελευταίου στοιχείου που εισήλθε κ του επόμενου του. 
Στην περίπτωση που για κάποιο wxn + wxn+1 <c/2 πέρνουμε το ζεύγος και το 
χρησιμοποιούμε σαν ενιαίο στοιχείο, το νέο στοιχείο αυτό, έστω Wn, θα 
αντιπροσωπεύει το άθροισμα των βαρών. Μόλις περάσουμε από όλα τα αντικείμενα τα 
έχουμε ως αποτέλεσμα δύο ήδη στοιχείων από την μια κάδους συμπληρωμένους με 
ΝextFit και από την άλλη στοιχεία μεγέθους < c/2. Θα ολοκληρώσουμε την 
συμπλήρωση τον κάδων με τον αλγόριθμο BFD. 
ΒΉΜΑ 1ο 
Για κάθε ζεύγος διαδοχικών αριθμών που ελέγχουμε υπολογίζουμε το συνολικό τους 
βάρος ξεκινώντας από το x1 +x . 
ΒΉΜΑ 2ο 
Αν το άθροισμα που προκύπτει wxn + wxn+1 < c/2 τότε αντιμετωπίζουμε τα xn , xn+1 
σαν ένα νέο αντικείμενο με βάρος το άθροισμα το βαρών τους και προχωράμε τον έλεγχο 
στο xn+1 και στο διαδοχικό του. 
ΒΉΜΑ 3ο 
Αν το άθροισμα που προκύπτει wxn + wxn+1 ≥ c/2 τότε τα τοποθετούμε σε ένα κάδο και 
τον γεμίζουμε με NF αλγοριθμο. Μόλις σταματήσει ο αλγόριθμος περνάμε τον έλεγχο 
στο τελευταίο στοιχείο που μπήκε στον κάδο και στον διαδοχικό του 
ΒΉΜΑ 4ο 
Τοποθετούμε τα νέα στοιχεία που έχουν δημιουργηθεί με βάρος <c/2 στους ήδη 
υπάρχοντες κάδους και στην συνέχεια μεταξύ τους χρησιμοποιώντας αλγόριθμο ΒFD 

Το ΒΡΡ παρότι είναι είναι ένα πρόβλημα μελετημένο διεξοδικά παραμένει σύγχρονο, 
καθώς οι διάφορες εκδοχές του όπως και οι εφαρμογές που αυτές έχουν το καθιστούν 
ενδιαφέρον. 
Ιδιαίτερα οι εφαρμογές του στον χώρο της βιομηχανίας και της πληροφορικής, 
αποτελούν αιτία περαιταίρω μελέτης του και αναζωπύρωσης του 
ενδιαφέροντος. Τόσο στους απλοϊκoύς αλγόριθμους, όσο και στους exact το πεδίο 
μελέτης παραμένει ανοιχτό. Ενώ ιδιαίτερο ενδιαφέρον παρουσιάζει η μελέτη του Bin 
Packing Problem παράλληλα με άλλα προβλήματα όπως το MapReduce καθώς και 
πως μπορούμε να αξιοποιήσουμε συνδυαστικά τους αλγόριθμους τον προβλημάτων 
ώστε να οδηγηθούμε σε καλύτερα αποτελέσματα. Όσον αφορά τη μελέτη του ΒΡΡ με 
τοποθέτηση διαδοχικών στοιχείων σε κοινό κάδο σε μονοπάτι η πρόκληση παραμένει 
ανοιχτή στο να βρούμε αποδοτικούς αλγόριθμους, αλλά και την επέκτασή τους σε 
άλλες δομές πέρα από το μονοπάτι όπως τα δέντρα και οι κλίκες. 
